// Auto-generated by scripts/build-vercel.mjs - DO NOT EDIT


// server/vercel-entry.ts
import "dotenv/config";
import express from "express";
import { createExpressMiddleware } from "@trpc/server/adapters/express";

// shared/const.ts
var COOKIE_NAME = "app_session_id";
var ONE_YEAR_MS = 1e3 * 60 * 60 * 24 * 365;
var UNAUTHED_ERR_MSG = "Please login (10001)";
var NOT_ADMIN_ERR_MSG = "You do not have required permission (10002)";

// server/_core/cookies.ts
function isSecureRequest(req) {
  if (req.protocol === "https") return true;
  const forwardedProto = req.headers["x-forwarded-proto"];
  if (!forwardedProto) return false;
  const protoList = Array.isArray(forwardedProto) ? forwardedProto : forwardedProto.split(",");
  return protoList.some((proto) => proto.trim().toLowerCase() === "https");
}
function getSessionCookieOptions(req) {
  return {
    httpOnly: true,
    path: "/",
    sameSite: "none",
    secure: isSecureRequest(req)
  };
}

// server/_core/systemRouter.ts
import { z } from "zod";

// server/_core/notification.ts
import { TRPCError } from "@trpc/server";

// server/_core/env.ts
var ENV = {
  appId: process.env.VITE_APP_ID ?? "",
  cookieSecret: process.env.JWT_SECRET ?? "",
  databaseUrl: process.env.DATABASE_URL ?? "",
  oAuthServerUrl: process.env.OAUTH_SERVER_URL ?? "",
  ownerOpenId: process.env.OWNER_OPEN_ID ?? "",
  isProduction: process.env.NODE_ENV === "production",
  forgeApiUrl: process.env.BUILT_IN_FORGE_API_URL ?? "",
  forgeApiKey: process.env.BUILT_IN_FORGE_API_KEY ?? "",
  // GitHub OAuth
  githubClientId: process.env.GITHUB_CLIENT_ID ?? "",
  githubClientSecret: process.env.GITHUB_CLIENT_SECRET ?? "",
  githubOwnerUsername: process.env.GITHUB_OWNER_USERNAME ?? "",
  // Supabase
  supabaseUrl: process.env.SUPABASE_URL ?? "",
  supabaseKey: process.env.SUPABASE_KEY ?? "",
  supabaseServiceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY ?? ""
};

// server/_core/notification.ts
var TITLE_MAX_LENGTH = 1200;
var CONTENT_MAX_LENGTH = 2e4;
var trimValue = (value) => value.trim();
var isNonEmptyString = (value) => typeof value === "string" && value.trim().length > 0;
var buildEndpointUrl = (baseUrl) => {
  const normalizedBase = baseUrl.endsWith("/") ? baseUrl : `${baseUrl}/`;
  return new URL(
    "webdevtoken.v1.WebDevService/SendNotification",
    normalizedBase
  ).toString();
};
var validatePayload = (input) => {
  if (!isNonEmptyString(input.title)) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Notification title is required."
    });
  }
  if (!isNonEmptyString(input.content)) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Notification content is required."
    });
  }
  const title = trimValue(input.title);
  const content = trimValue(input.content);
  if (title.length > TITLE_MAX_LENGTH) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: `Notification title must be at most ${TITLE_MAX_LENGTH} characters.`
    });
  }
  if (content.length > CONTENT_MAX_LENGTH) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: `Notification content must be at most ${CONTENT_MAX_LENGTH} characters.`
    });
  }
  return { title, content };
};
async function notifyOwner(payload) {
  const { title, content } = validatePayload(payload);
  if (!ENV.forgeApiUrl) {
    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "Notification service URL is not configured."
    });
  }
  if (!ENV.forgeApiKey) {
    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "Notification service API key is not configured."
    });
  }
  const endpoint = buildEndpointUrl(ENV.forgeApiUrl);
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        accept: "application/json",
        authorization: `Bearer ${ENV.forgeApiKey}`,
        "content-type": "application/json",
        "connect-protocol-version": "1"
      },
      body: JSON.stringify({ title, content })
    });
    if (!response.ok) {
      const detail = await response.text().catch(() => "");
      console.warn(
        `[Notification] Failed to notify owner (${response.status} ${response.statusText})${detail ? `: ${detail}` : ""}`
      );
      return false;
    }
    return true;
  } catch (error) {
    console.warn("[Notification] Error calling notification service:", error);
    return false;
  }
}

// server/_core/trpc.ts
import { initTRPC, TRPCError as TRPCError2 } from "@trpc/server";
import superjson from "superjson";
var t = initTRPC.context().create({
  transformer: superjson
});
var router = t.router;
var publicProcedure = t.procedure;
var requireUser = t.middleware(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    throw new TRPCError2({ code: "UNAUTHORIZED", message: UNAUTHED_ERR_MSG });
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user
    }
  });
});
var protectedProcedure = t.procedure.use(requireUser);
var adminProcedure = t.procedure.use(
  t.middleware(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user || ctx.user.role !== "admin") {
      throw new TRPCError2({ code: "FORBIDDEN", message: NOT_ADMIN_ERR_MSG });
    }
    return next({
      ctx: {
        ...ctx,
        user: ctx.user
      }
    });
  })
);

// server/_core/systemRouter.ts
var systemRouter = router({
  health: publicProcedure.input(
    z.object({
      timestamp: z.number().min(0, "timestamp cannot be negative")
    })
  ).query(() => ({
    ok: true
  })),
  notifyOwner: adminProcedure.input(
    z.object({
      title: z.string().min(1, "title is required"),
      content: z.string().min(1, "content is required")
    })
  ).mutation(async ({ input }) => {
    const delivered = await notifyOwner(input);
    return {
      success: delivered
    };
  })
});

// server/routers.ts
import { z as z2 } from "zod";

// server/db.ts
import { createClient } from "@supabase/supabase-js";
var _supabase = null;
var _supabaseAdmin = null;
function getSupabase() {
  if (!_supabase) {
    const url = process.env.SUPABASE_URL;
    const key = process.env.SUPABASE_KEY;
    if (!url || !key) {
      throw new Error("SUPABASE_URL and SUPABASE_KEY must be set");
    }
    _supabase = createClient(url, key);
  }
  return _supabase;
}
function getSupabaseAdmin() {
  if (!_supabaseAdmin) {
    const url = process.env.SUPABASE_URL;
    const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
    if (!url || !key) {
      throw new Error("SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set");
    }
    _supabaseAdmin = createClient(url, key);
  }
  return _supabaseAdmin;
}
function profileToCamel(row) {
  return {
    id: row.id,
    fullName: row.full_name,
    title: row.title,
    bio: row.bio,
    heroTagline: row.hero_tagline,
    heroSubtitle: row.hero_subtitle,
    avatarUrl: row.avatar_url,
    resumeUrl: row.resume_url,
    githubUrl: row.github_url,
    linkedinUrl: row.linkedin_url,
    twitterUrl: row.twitter_url,
    email: row.email,
    phone: row.phone,
    location: row.location,
    yearsExperience: row.years_experience,
    projectsDelivered: row.projects_delivered,
    openSourceContributions: row.open_source_contributions,
    clientSatisfaction: row.client_satisfaction,
    availableForWork: row.available_for_work ? 1 : 0,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function projectToCamel(row) {
  return {
    id: row.id,
    title: row.title,
    description: row.description,
    imageUrl: row.image_url,
    liveUrl: row.live_url,
    githubUrl: row.github_url,
    tags: row.tags,
    featured: row.featured ? 1 : 0,
    sortOrder: row.sort_order,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function experienceToCamel(row) {
  return {
    id: row.id,
    role: row.role,
    company: row.company,
    period: row.period,
    description: row.description,
    tags: row.tags,
    sortOrder: row.sort_order,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function skillCategoryToCamel(row) {
  return {
    id: row.id,
    title: row.title,
    icon: row.icon,
    skills: row.skills,
    sortOrder: row.sort_order,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function profileToSnake(data) {
  const map = {
    fullName: "full_name",
    title: "title",
    bio: "bio",
    heroTagline: "hero_tagline",
    heroSubtitle: "hero_subtitle",
    avatarUrl: "avatar_url",
    resumeUrl: "resume_url",
    githubUrl: "github_url",
    linkedinUrl: "linkedin_url",
    twitterUrl: "twitter_url",
    email: "email",
    phone: "phone",
    location: "location",
    yearsExperience: "years_experience",
    projectsDelivered: "projects_delivered",
    openSourceContributions: "open_source_contributions",
    clientSatisfaction: "client_satisfaction",
    availableForWork: "available_for_work"
  };
  const result = {};
  for (const [key, value] of Object.entries(data)) {
    if (key === "id") continue;
    const snakeKey = map[key] || key;
    if (key === "availableForWork") {
      result[snakeKey] = value === 1 || value === true;
    } else {
      result[snakeKey] = value;
    }
  }
  result.updated_at = (/* @__PURE__ */ new Date()).toISOString();
  return result;
}
function projectToSnake(data) {
  const map = {
    title: "title",
    description: "description",
    imageUrl: "image_url",
    liveUrl: "live_url",
    githubUrl: "github_url",
    tags: "tags",
    featured: "featured",
    sortOrder: "sort_order"
  };
  const result = {};
  for (const [key, value] of Object.entries(data)) {
    if (key === "id") continue;
    const snakeKey = map[key] || key;
    if (key === "featured") {
      result[snakeKey] = value === 1 || value === true;
    } else {
      result[snakeKey] = value;
    }
  }
  result.updated_at = (/* @__PURE__ */ new Date()).toISOString();
  return result;
}
function experienceToSnake(data) {
  const map = {
    role: "role",
    company: "company",
    period: "period",
    description: "description",
    tags: "tags",
    sortOrder: "sort_order"
  };
  const result = {};
  for (const [key, value] of Object.entries(data)) {
    if (key === "id") continue;
    const snakeKey = map[key] || key;
    result[snakeKey] = value;
  }
  result.updated_at = (/* @__PURE__ */ new Date()).toISOString();
  return result;
}
function skillCategoryToSnake(data) {
  const map = {
    title: "title",
    icon: "icon",
    skills: "skills",
    sortOrder: "sort_order"
  };
  const result = {};
  for (const [key, value] of Object.entries(data)) {
    if (key === "id") continue;
    const snakeKey = map[key] || key;
    result[snakeKey] = value;
  }
  result.updated_at = (/* @__PURE__ */ new Date()).toISOString();
  return result;
}
async function getProfile() {
  const sb = getSupabase();
  const { data, error } = await sb.from("profile").select("*").limit(1).single();
  if (error || !data) return null;
  return profileToCamel(data);
}
async function upsertProfile(input) {
  const sb = getSupabaseAdmin();
  const snakeData = profileToSnake(input);
  const existing = await getProfile();
  if (existing) {
    const { data, error } = await sb.from("profile").update(snakeData).eq("id", existing.id).select().single();
    if (error) throw new Error(`Failed to update profile: ${error.message}`);
    return profileToCamel(data);
  } else {
    const { data, error } = await sb.from("profile").insert(snakeData).select().single();
    if (error) throw new Error(`Failed to create profile: ${error.message}`);
    return profileToCamel(data);
  }
}
async function getProjects() {
  const sb = getSupabase();
  const { data, error } = await sb.from("projects").select("*").order("sort_order", { ascending: true });
  if (error || !data) return [];
  return data.map(projectToCamel);
}
async function createProject(input) {
  const sb = getSupabaseAdmin();
  const snakeData = projectToSnake(input);
  const { data, error } = await sb.from("projects").insert(snakeData).select().single();
  if (error) throw new Error(`Failed to create project: ${error.message}`);
  return projectToCamel(data);
}
async function updateProject(id, input) {
  const sb = getSupabaseAdmin();
  const snakeData = projectToSnake(input);
  const { data, error } = await sb.from("projects").update(snakeData).eq("id", id).select().single();
  if (error) throw new Error(`Failed to update project: ${error.message}`);
  return projectToCamel(data);
}
async function deleteProject(id) {
  const sb = getSupabaseAdmin();
  const { error } = await sb.from("projects").delete().eq("id", id);
  if (error) throw new Error(`Failed to delete project: ${error.message}`);
}
async function getExperiences() {
  const sb = getSupabase();
  const { data, error } = await sb.from("experiences").select("*").order("sort_order", { ascending: true });
  if (error || !data) return [];
  return data.map(experienceToCamel);
}
async function createExperience(input) {
  const sb = getSupabaseAdmin();
  const snakeData = experienceToSnake(input);
  const { data, error } = await sb.from("experiences").insert(snakeData).select().single();
  if (error) throw new Error(`Failed to create experience: ${error.message}`);
  return experienceToCamel(data);
}
async function updateExperience(id, input) {
  const sb = getSupabaseAdmin();
  const snakeData = experienceToSnake(input);
  const { data, error } = await sb.from("experiences").update(snakeData).eq("id", id).select().single();
  if (error) throw new Error(`Failed to update experience: ${error.message}`);
  return experienceToCamel(data);
}
async function deleteExperience(id) {
  const sb = getSupabaseAdmin();
  const { error } = await sb.from("experiences").delete().eq("id", id);
  if (error) throw new Error(`Failed to delete experience: ${error.message}`);
}
async function getSkillCategories() {
  const sb = getSupabase();
  const { data, error } = await sb.from("skill_categories").select("*").order("sort_order", { ascending: true });
  if (error || !data) return [];
  return data.map(skillCategoryToCamel);
}
async function createSkillCategory(input) {
  const sb = getSupabaseAdmin();
  const snakeData = skillCategoryToSnake(input);
  const { data, error } = await sb.from("skill_categories").insert(snakeData).select().single();
  if (error)
    throw new Error(`Failed to create skill category: ${error.message}`);
  return skillCategoryToCamel(data);
}
async function updateSkillCategory(id, input) {
  const sb = getSupabaseAdmin();
  const snakeData = skillCategoryToSnake(input);
  const { data, error } = await sb.from("skill_categories").update(snakeData).eq("id", id).select().single();
  if (error)
    throw new Error(`Failed to update skill category: ${error.message}`);
  return skillCategoryToCamel(data);
}
async function deleteSkillCategory(id) {
  const sb = getSupabaseAdmin();
  const { error } = await sb.from("skill_categories").delete().eq("id", id);
  if (error)
    throw new Error(`Failed to delete skill category: ${error.message}`);
}
async function getFullPortfolio() {
  const [profileData, projectsData, experiencesData, skillsData] = await Promise.all([
    getProfile(),
    getProjects(),
    getExperiences(),
    getSkillCategories()
  ]);
  return {
    profile: profileData,
    projects: projectsData,
    experiences: experiencesData,
    skills: skillsData
  };
}

// server/routers.ts
var appRouter = router({
  system: systemRouter,
  auth: router({
    me: publicProcedure.query((opts) => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return { success: true };
    })
  }),
  // ==========================================
  // PUBLIC: Get full portfolio data
  // ==========================================
  portfolio: router({
    getAll: publicProcedure.query(async () => {
      return getFullPortfolio();
    })
  }),
  // ==========================================
  // ADMIN: Profile management
  // ==========================================
  adminProfile: router({
    get: adminProcedure.query(async () => {
      return getProfile();
    }),
    update: adminProcedure.input(
      z2.object({
        fullName: z2.string().optional(),
        title: z2.string().optional(),
        bio: z2.string().optional(),
        heroTagline: z2.string().optional(),
        heroSubtitle: z2.string().optional(),
        avatarUrl: z2.string().optional(),
        resumeUrl: z2.string().optional(),
        githubUrl: z2.string().optional(),
        linkedinUrl: z2.string().optional(),
        twitterUrl: z2.string().optional(),
        email: z2.string().optional(),
        phone: z2.string().optional(),
        location: z2.string().optional(),
        yearsExperience: z2.string().optional(),
        projectsDelivered: z2.string().optional(),
        openSourceContributions: z2.string().optional(),
        clientSatisfaction: z2.string().optional(),
        availableForWork: z2.number().optional()
      })
    ).mutation(async ({ input }) => {
      return upsertProfile(input);
    })
  }),
  // ==========================================
  // ADMIN: Projects management
  // ==========================================
  adminProjects: router({
    list: adminProcedure.query(async () => {
      return getProjects();
    }),
    create: adminProcedure.input(
      z2.object({
        title: z2.string(),
        description: z2.string().optional(),
        imageUrl: z2.string().optional(),
        liveUrl: z2.string().optional(),
        githubUrl: z2.string().optional(),
        tags: z2.string().optional(),
        featured: z2.number().optional(),
        sortOrder: z2.number().optional()
      })
    ).mutation(async ({ input }) => {
      return createProject(input);
    }),
    update: adminProcedure.input(
      z2.object({
        id: z2.number(),
        title: z2.string().optional(),
        description: z2.string().optional(),
        imageUrl: z2.string().optional(),
        liveUrl: z2.string().optional(),
        githubUrl: z2.string().optional(),
        tags: z2.string().optional(),
        featured: z2.number().optional(),
        sortOrder: z2.number().optional()
      })
    ).mutation(async ({ input }) => {
      const { id, ...data } = input;
      return updateProject(id, data);
    }),
    delete: adminProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ input }) => {
      await deleteProject(input.id);
      return { success: true };
    })
  }),
  // ==========================================
  // ADMIN: Experiences management
  // ==========================================
  adminExperiences: router({
    list: adminProcedure.query(async () => {
      return getExperiences();
    }),
    create: adminProcedure.input(
      z2.object({
        role: z2.string(),
        company: z2.string(),
        period: z2.string(),
        description: z2.string().optional(),
        tags: z2.string().optional(),
        sortOrder: z2.number().optional()
      })
    ).mutation(async ({ input }) => {
      return createExperience(input);
    }),
    update: adminProcedure.input(
      z2.object({
        id: z2.number(),
        role: z2.string().optional(),
        company: z2.string().optional(),
        period: z2.string().optional(),
        description: z2.string().optional(),
        tags: z2.string().optional(),
        sortOrder: z2.number().optional()
      })
    ).mutation(async ({ input }) => {
      const { id, ...data } = input;
      return updateExperience(id, data);
    }),
    delete: adminProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ input }) => {
      await deleteExperience(input.id);
      return { success: true };
    })
  }),
  // ==========================================
  // ADMIN: Skills management
  // ==========================================
  adminSkills: router({
    list: adminProcedure.query(async () => {
      return getSkillCategories();
    }),
    create: adminProcedure.input(
      z2.object({
        title: z2.string(),
        icon: z2.string().optional(),
        skills: z2.string().optional(),
        sortOrder: z2.number().optional()
      })
    ).mutation(async ({ input }) => {
      return createSkillCategory(input);
    }),
    update: adminProcedure.input(
      z2.object({
        id: z2.number(),
        title: z2.string().optional(),
        icon: z2.string().optional(),
        skills: z2.string().optional(),
        sortOrder: z2.number().optional()
      })
    ).mutation(async ({ input }) => {
      const { id, ...data } = input;
      return updateSkillCategory(id, data);
    }),
    delete: adminProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ input }) => {
      await deleteSkillCategory(input.id);
      return { success: true };
    })
  })
});

// shared/_core/errors.ts
var HttpError = class extends Error {
  constructor(statusCode, message) {
    super(message);
    this.statusCode = statusCode;
    this.name = "HttpError";
  }
};
var ForbiddenError = (msg) => new HttpError(403, msg);

// server/_core/sdk.ts
import { parse as parseCookieHeader } from "cookie";
import { SignJWT, jwtVerify } from "jose";
import { createClient as createClient2 } from "@supabase/supabase-js";
var isNonEmptyString2 = (value) => typeof value === "string" && value.length > 0;
function normalizeUser(row) {
  return {
    id: row.id,
    openId: row.github_id,
    name: row.name,
    email: row.email,
    loginMethod: "github",
    role: row.role,
    createdAt: new Date(row.created_at),
    updatedAt: new Date(row.updated_at),
    lastSignedIn: new Date(row.last_signed_in),
    avatarUrl: row.avatar_url,
    githubUsername: row.github_username
  };
}
var _supabaseAdmin2 = null;
function getSupabaseAdmin2() {
  if (!_supabaseAdmin2) {
    const url = process.env.SUPABASE_URL;
    const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
    if (!url || !key) {
      throw new Error("SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set");
    }
    _supabaseAdmin2 = createClient2(url, key);
  }
  return _supabaseAdmin2;
}
var SDKServer = class {
  parseCookies(cookieHeader) {
    if (!cookieHeader) {
      return /* @__PURE__ */ new Map();
    }
    const parsed = parseCookieHeader(cookieHeader);
    return new Map(Object.entries(parsed));
  }
  getSessionSecret() {
    const secret = ENV.cookieSecret;
    if (!secret) throw new Error("JWT_SECRET must be set");
    return new TextEncoder().encode(secret);
  }
  async createSessionToken(githubId, options = {}) {
    const issuedAt = Date.now();
    const expiresInMs = options.expiresInMs ?? 365 * 24 * 60 * 60 * 1e3;
    const expirationSeconds = Math.floor((issuedAt + expiresInMs) / 1e3);
    const secretKey = this.getSessionSecret();
    return new SignJWT({
      githubId,
      name: options.name || ""
    }).setProtectedHeader({ alg: "HS256", typ: "JWT" }).setExpirationTime(expirationSeconds).sign(secretKey);
  }
  async verifySession(cookieValue) {
    if (!cookieValue) return null;
    try {
      const secretKey = this.getSessionSecret();
      const { payload } = await jwtVerify(cookieValue, secretKey, {
        algorithms: ["HS256"]
      });
      const { githubId, name } = payload;
      const id = githubId || payload.openId;
      const userName = name || payload.name;
      if (!isNonEmptyString2(id)) {
        console.warn("[Auth] Session payload missing githubId");
        return null;
      }
      return {
        githubId: id,
        name: userName || ""
      };
    } catch (error) {
      console.warn("[Auth] Session verification failed", String(error));
      return null;
    }
  }
  async upsertGitHubUser(githubUser) {
    const sb = getSupabaseAdmin2();
    const ownerGithubUsername = process.env.GITHUB_OWNER_USERNAME || "";
    const { data: existing } = await sb.from("app_users").select("*").eq("github_id", githubUser.githubId).single();
    const isOwner = ownerGithubUsername && githubUser.githubUsername.toLowerCase() === ownerGithubUsername.toLowerCase();
    if (existing) {
      const { data, error } = await sb.from("app_users").update({
        github_username: githubUser.githubUsername,
        name: githubUser.name,
        email: githubUser.email,
        avatar_url: githubUser.avatarUrl,
        role: isOwner ? "admin" : existing.role,
        last_signed_in: (/* @__PURE__ */ new Date()).toISOString(),
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      }).eq("github_id", githubUser.githubId).select().single();
      if (error) throw new Error(`Failed to update user: ${error.message}`);
      return normalizeUser(data);
    } else {
      const { data, error } = await sb.from("app_users").insert({
        github_id: githubUser.githubId,
        github_username: githubUser.githubUsername,
        name: githubUser.name,
        email: githubUser.email,
        avatar_url: githubUser.avatarUrl,
        role: isOwner ? "admin" : "user"
      }).select().single();
      if (error) throw new Error(`Failed to create user: ${error.message}`);
      return normalizeUser(data);
    }
  }
  async getUserByGitHubId(githubId) {
    const sb = getSupabaseAdmin2();
    const { data, error } = await sb.from("app_users").select("*").eq("github_id", githubId).single();
    if (error || !data) return null;
    return normalizeUser(data);
  }
  async authenticateRequest(req) {
    const cookies = this.parseCookies(req.headers.cookie);
    const sessionCookie = cookies.get(COOKIE_NAME);
    const session = await this.verifySession(sessionCookie);
    if (!session) {
      throw ForbiddenError("Invalid session cookie");
    }
    const user = await this.getUserByGitHubId(session.githubId);
    if (!user) {
      throw ForbiddenError("User not found");
    }
    return user;
  }
};
var sdk = new SDKServer();

// server/_core/context.ts
async function createContext(opts) {
  let user = null;
  try {
    user = await sdk.authenticateRequest(opts.req);
  } catch (error) {
    user = null;
  }
  return {
    req: opts.req,
    res: opts.res,
    user
  };
}

// server/_core/oauth.ts
import axios from "axios";
var ONE_YEAR_MS2 = 365 * 24 * 60 * 60 * 1e3;
function getGitHubClientId() {
  return process.env.GITHUB_CLIENT_ID || "";
}
function getGitHubClientSecret() {
  return process.env.GITHUB_CLIENT_SECRET || "";
}
function registerOAuthRoutes(app2) {
  app2.get("/api/auth/github", (req, res) => {
    const clientId = getGitHubClientId();
    if (!clientId) {
      res.status(500).json({ error: "GITHUB_CLIENT_ID not configured" });
      return;
    }
    const protocol = req.headers["x-forwarded-proto"] || req.protocol || "https";
    const host = req.headers["x-forwarded-host"] || req.headers.host;
    const callbackUrl = `${protocol}://${host}/api/auth/github/callback`;
    const returnPath = req.query.returnPath || "/";
    const state = Buffer.from(JSON.stringify({ returnPath, callbackUrl })).toString("base64url");
    const githubAuthUrl = `https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${encodeURIComponent(callbackUrl)}&scope=read:user%20user:email&state=${state}`;
    res.redirect(302, githubAuthUrl);
  });
  app2.get("/api/auth/github/callback", async (req, res) => {
    const code = req.query.code;
    const state = req.query.state;
    if (!code) {
      res.status(400).json({ error: "Authorization code is required" });
      return;
    }
    let returnPath = "/";
    try {
      if (state) {
        const decoded = JSON.parse(Buffer.from(state, "base64url").toString());
        returnPath = decoded.returnPath || "/";
      }
    } catch {
    }
    try {
      const tokenResponse = await axios.post(
        "https://github.com/login/oauth/access_token",
        {
          client_id: getGitHubClientId(),
          client_secret: getGitHubClientSecret(),
          code
        },
        {
          headers: { Accept: "application/json" },
          timeout: 1e4
        }
      );
      const accessToken = tokenResponse.data.access_token;
      if (!accessToken) {
        console.error("[GitHub OAuth] No access token received:", tokenResponse.data);
        res.status(400).json({ error: "Failed to get access token from GitHub" });
        return;
      }
      const [userResponse, emailsResponse] = await Promise.all([
        axios.get("https://api.github.com/user", {
          headers: { Authorization: `Bearer ${accessToken}`, Accept: "application/json" },
          timeout: 1e4
        }),
        axios.get("https://api.github.com/user/emails", {
          headers: { Authorization: `Bearer ${accessToken}`, Accept: "application/json" },
          timeout: 1e4
        })
      ]);
      const githubUser = userResponse.data;
      const emails = emailsResponse.data;
      const primaryEmail = emails.find((e) => e.primary && e.verified)?.email || emails.find((e) => e.verified)?.email || githubUser.email;
      const user = await sdk.upsertGitHubUser({
        githubId: String(githubUser.id),
        githubUsername: githubUser.login,
        name: githubUser.name || githubUser.login,
        email: primaryEmail || null,
        avatarUrl: githubUser.avatar_url || null
      });
      const sessionToken = await sdk.createSessionToken(String(githubUser.id), {
        name: user.name || githubUser.login,
        expiresInMs: ONE_YEAR_MS2
      });
      const cookieOptions = getSessionCookieOptions(req);
      res.cookie(COOKIE_NAME, sessionToken, { ...cookieOptions, maxAge: ONE_YEAR_MS2 });
      res.redirect(302, returnPath);
    } catch (error) {
      console.error("[GitHub OAuth] Callback failed:", error?.response?.data || error.message);
      res.status(500).json({ error: "GitHub OAuth callback failed" });
    }
  });
  app2.get("/api/oauth/callback", (_req, res) => {
    res.redirect(302, "/");
  });
}

// server/vercel-entry.ts
var app = express();
app.set("trust proxy", 1);
app.use(express.json({ limit: "50mb" }));
app.use(express.urlencoded({ limit: "50mb", extended: true }));
registerOAuthRoutes(app);
app.use(
  "/api/trpc",
  createExpressMiddleware({
    router: appRouter,
    createContext
  })
);
app.get("/api/health", (_req, res) => {
  res.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
});
var vercel_entry_default = app;
export {
  vercel_entry_default as default
};
